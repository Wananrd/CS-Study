* MySQL
  * <a href="#一条SQL查询语句是如何执行的">一条SQL查询语句是如何执行的？</a>
    * MySQL基本架构
    * 连接器
    * 查询缓存
    * 分析器
    * 优化器
    * 执行器
  * 日志系统：一条SQL更新语句是如何执行的？
    * redo log
    * bin log

## <div id = "一条SQL查询语句是如何执行的">一条SQL查询语句是如何执行的</div>

SQL语句

~~~sql
select * from T where ID=10;
~~~

### MySQL基本架构

总的来说分为两层：`server层`与`存储引擎层`

<img src="E:\gitcode\cs-study\pic\1jg.jpg" alt="MySQL架构图" style="zoom:25%;" />

有了这个基础的认知下面将 select * from T where ID=10;的执行流程在下面走一遍。

### 连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接。



**连接命令**

> mysql -h$ip -P$port -u$user -p

**注意：**

* 密码虽然可以在p后写，但这样会导致密码泄露。

* 完成TCP握手后，就认证身份。

* 密码错误，收到"Access denied for user"提示信息。

* 认证通过，连接器到权限表里面查你拥有的权限。

* 客户端太久没动静，连接器就会断开，默认8h。

  > 断开后客户端发起请求，就会收到一个错误提醒： 
  >
  > Lost connection to MySQL server during query。



**长连接与短连接**

**长连接：**指的是连接成功后，如果客户端持续发请求，则一直使用一个连接。

**短连接：**是指每次执行完几个很少的命令后就断开连接。

**问题：**全是用长连接内存涨得很快。最终OOM系统强行杀掉，现象就是MySQL重启了。

**解决方案：**

1. 定期断开长连接。使用一段时间或是程序中判断执行过一个占用内存的大查询后，断开连接，之后要查询重新连接。
2. 可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。



### 查询缓存

MySQL拿到一个查询请求后，会先到缓存看看，之前是不是执行过这条语句。

之前执行过的语句可能会以key-value对的形式，被直接缓存在内存中。



**建议：**大多情况建议不要查询缓存，因为查询缓存往往弊大于利。

> 查询缓存的失效非常频繁，只要有一个表进行更新，这个表上所有的查询缓存都会被清空。

>  select SQL_CACHE * from T where ID=10；
>
> 可以使用此代码不用缓存。MySQL8.0开始缓存被删除。



### 分析器

对SQL语法做解析。



**执行过程**

1. 首先会做“词法分析”MySQL需要识别出字符串分别是什么，代表什么。

2. 做完后进行“语法分析”，语法分析会判断你输入的MySQL语句是否满足MySQL语法。

   > 若不满足，则会有下列语法：
   >
   > ERROR 1064 (42000): You have an error in your SQL syntax;......



### 优化器

优化器是在表有多个索引的时候，决定用哪个索引；

或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序。



**例如：**select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;

> 有两个方案：
>
> 可以先从t1表中找到c＝10在和t2表的d＝20匹配。
> 也可以先找到t2表的d＝20，再找到t1表的c＝10。
>
> 优化器作用就是决定使用哪个方案。



### 执行器

开始执行时候，首先要判断你对这个表T有没有执行权限。

(如果命中查询缓存，会在查询缓存返回结果的时候做权限验证)

> 如果没有权限，返回权限错误。
>
> ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'

> 有权限，打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，使用引擎提供的接口。



**引擎执行流程**

执行语句`select * from T where ID=10;`

1. 调用InnoDB引擎接口去这个表的第一行，判断ID是不是等于10，如果不是则跳过，如果是则将这行存在结果集中。
2. 调用引擎接口取“下一行”，重复相同的逻辑判断，直到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的结果行组成集作为记录返回给顾客。



## 日志系统：一条SQL更新语句是如何执行的

SQL语句

~~~SQL
update T set c=c+1 where ID=2;
~~~

根据上面的内容我们可以大概知道执行流程。

1. 连接数据库(`连接器`)
2. 会把表T上所有缓存结果都清空[这也是我们不使用`查询缓存`的原因]
3. `分析器`会通过词法和语法解析知道这是一条更新语句
4. `优化器`决定要使用ID这个索引
5. `执行器`负责具体执行，找到这一行，然后更新

与查询流程**不同之处**，更新还涉及两个重要的**日志模块**。



### redo log(重做日志)

**简述：**redo log就类似于鲁迅笔下的《孔乙己》。

*如果有人要赊账，掌柜有两种做法。
一种是找到账本上把这次账记上去。
另外一种是先记到黑板上，等打烊后把账本拿出来记上去。*



**WAL：**

粉板和账本配合的技术，就是MySQL中的WAL技术。

全称是**Write-Ahead Logging**，关键点是先写日志，空闲时候写磁盘。



**WAL具体说明**：

当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。

同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面。



**数据结构**

掌柜的黑板不是无限大的，于是出现以下情况。

*如果赊账的人很多，粉板写不下，就只好放下手中的活，先将粉板内容记录到账本上，再擦去粉板记录，为新的赊账腾出空间。*

与此类似，innoDB的redo log是固定大小的。比如可以配置为一组4个文件，每个文件大小1GB，总共可以记录4GB。

这是redo log的数据结构：`redo log会从头开始写，写到末尾又回到开头开始写`。【循环链表】

<img src="E:\gitcode\cs-study\pic\2hb.jpg" alt="MySQL架构图" style="zoom:33%;" />



**优点**

有了redo log，InnoDB就可以保证即使数据库重启，之间提交的记录都不会丢失，这个能力称为**crash-safe**。



### bin log(归档日志)



**为什么会有两份日志？**

MySQL自带的引擎MyISAM没有**crash-safe**的能力。



**两份日志的区别**

| 区别     | redo log                       | bin  log                         |
| -------- | ------------------------------ | -------------------------------- |
| 持有对象 | InnoDB引擎层持有               | Server层实现，所有引擎都可以使用 |
| 记录内容 | 物理日志\|记录“数据修改后的值” | 逻辑日志\|记录"修改内容的操作"   |
| 内存大小 | 循环写，空间会用完             | 追加写，写完会切换到下一个       |



**执行流程**

回到最初的SQL语句`update T set c=c+1 where ID=2`;，让我们演示它的执行流程。

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。



<img src="E:\gitcode\cs-study\pic\3sx.jpg" alt="流程图" style="zoom:33%;" />



### 两阶段提交

将redo log的写入拆成了两个步骤：prepare和commit这就是**两阶段提交**。



**为什么要有两阶段提交**

为了保证事务的一致性，整个执行流程是一个事务，当某个环节出现了问题，就会回滚事务。



**如何找到数据库半个月内的任意一秒**

1. 找最近一次全量备份
2. 从那时开始，将备份的bin log依次取出，重放到需要的那一秒



**不使用两阶段提交问题**

1. 先写redo log再写bin log

   > 假设在redo log写完，bin log未写完，数据库异常重启。所以恢复后的c值正确1，但如果用bin log恢复数据库的话c是0，与原库值不同。

2. 先写bin log再写redo log

   > 在binlog写完后crash，redolog还没写，所以c的值是0，但如果用binlog恢复数据库的话c是1，与原库值不同。



## 事务隔离：为什么你改变了我还看不见

事务就是要保证一组数据库操作，要么全部成功，要么全部失败。

在MySQL中，事务支持是在引擎层实现的。MySQL是支持多引擎的系统，但不是所有的引擎都支持事务。原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。



提到事务，就会想到**事务特性：**

A(Atomicity)：原子性

C(Consistency)：一致性

I(Isolation)：隔离性

D(Durability)：持久性



**问题**

当数据库上有多个事务同时执行的时候，就可能出现**脏读、不可重复度、幻读**的问题，为了解决这些问题，就有了“**隔离级别**”的概念。



### 隔离性与隔离级别

`隔离得越严实，效率就会越低`

**标准的事务隔离**：读未提交 < 读提交 < 可重复度 < 串行化

* 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
* 读提交：一个事务提交之后，它的变更才会被其他事务看到。
* 可重复度：一个事物执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
* 串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

<img src="E:\gitcode\cs-study\pic\4ex.jpg" alt="例子" style="zoom:33%;" />

在不同隔离级别下的返回结果：

* 读未提交：V1[2]、V2[2]、V3[2]

* 读提交：V1[1]、V2[2]、V3[2]

  > **事务B的更新在提交后才能被A看到**。

* 可重复度：V1[1]、V2[1]、V3[2]

  > **事务在执行期间看到的数据前后必须是一致的**。

* 串行化：V1[1]、V2[1]、V3[2]

  > **在执行事务B“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。**



**隔离的实现**

实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。

* “可重复读”：视图在事务启动时创建的。
* “读提交”：视图是在每个SQL语句开始执行的时候创建的。
* “读未提交”：直接返回记录上的最新值，没有视图概念。
* “串行化”：直接用枷锁方式避免访问



**不同数据库之间不同的细节**

Oracle数据库默认隔离级别`读提交`

因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致性，需要将MySQL的隔离级别设置为“读提交”。

> 配置方式：
>
> 将启动参数transaction-isolation的值设置为READ-COMMITTED
>
> 可以用show variables来查看当前的值。



**可重复读的场景**

*假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。*



### 事务隔离的实现

*具体说明“可重复读”*



MySQL中，实际上每条记录在更新时候都会同时记录一条回滚操作。

记录上的最新值，通过回滚操作，都可以得到前一个状态的值。



假设一个值从1按顺序改成了2、3、4，在回滚日志里面就有类似下面的记录。

<img src="E:\gitcode\cs-study\pic\5rb.jpg" alt="例子" style="zoom:50%;" />

同一条记录在系统中可以存在多个版本（MVCC），多版本并发控制。



**回滚日志什么时候删除**

回滚日志总不能一直存在，什么时候删除呢？

答案：在系统不需要的时候删除。

也就是说：系统会判断，当没有事务在需要用到这些回滚日志时，回滚日志会被删除。



**什么时候不需要了呢？**

当系统里没有比这回滚日志更早的read-view的时候。



**为什么尽量不要使用长事务？**

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。





### 事务的启动方式

方式一：**显式启动事务语句**， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。

方式二：set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。



**建议：**

为避免长事务，建议总是使用set autocommit = 1，通过显示语句的方式来启动事务。

> 有的同学会纠结“多一次交互”的问题，可以执行commit work and chain。
>
> 提交事务并自动启动下一个事务。



**技巧**

可以通过下面的语句查找持续时间超过60s的事务。

~~~SQL
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
~~~



## 索引

**索引的出现是为了提高数据查询的效率，就像书的目录一样。**



### 索引的常见模型

三种常见的简单的数据结构：**哈希表**、**有序数组**、**搜索树**



**哈希表**

键-值：key-value存储

把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种特殊的方法拉出一个链表。



假设：现在需要维护一个身份证信息和姓名的表，需要根据对应的身份证号查找对应的名字。这时的哈希索引如下：

<img src="E:\gitcode\cs-study\pic\6hs.jpg" alt="例子" style="zoom:50%;" />

查找User2：

> 首先根据身份证号推算出N；然后按顺序遍历，找到User2



**缺陷**：区间查询的速度很慢。

**技巧**：哈希表只有用于等值查询的场景。



**有序数组**

仅仅在查询效率来看，有序数组在等值查询和范围查询的性能非常优秀。

<img src="E:\gitcode\cs-study\pic\7dz.jpg" alt="例子" style="zoom:50%;" />

用二分法就可以快速查到ID。时间复杂度O(log(N))。



**缺陷**：往中间插入一个值成本太高

**技巧**：有序数组索引只适用于静态存储引擎。



**搜索树**

相比上面两种数据结构，二叉搜索树来实现的话，查找的效率O(log(N))，修改的效率(保持这棵树是平衡二叉树)效率也是O(log(N))。

<img src="E:\gitcode\cs-study\pic\8tree.jpg" alt="例子" style="zoom:50%;" />



实际上大多数数据库存储却不使用二叉树。

原因：**索引不只存在内存中，还要写到磁盘上。**

> 如果100万结点的平衡二叉树，一次查寻需要访问20个数据块，这个查询效率挺慢的



**N叉树**

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。



以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。



### InnoDB的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。

又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。



每一个索引在 InnoDB 里面对应一棵 B+ 树。



**例子**

~~~sql
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
~~~

表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。

<img src="E:\gitcode\cs-study\pic\9ex.jpg" alt="例子" style="zoom:50%;" />

从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为**聚簇索引**（clustered index）。
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为**二级索引**（secondary index）。



基于上图：我们来讨论一下**基于主键索引和普通索引的查询有什么区别**？

* 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
* 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。



**结论**：也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。



### 索引维护

B+树为了维护索引的有序性，在插入新的值的时候需要做必要的维护。



**例子**

以上图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。
除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。



**自增主键的使用**

基于上，那我们什么时候应该使用自增主键？

自增主键的定义：`NOT NULL PRIMARY KEY AUTO_INCREMENT`



**说明**：

1. 自增主键插入数据模式，正符合了递增插入的场景，每次插入都是追加操作，不会挪动其他记录，也不会触发叶子结点的分裂。而有业务逻辑的字段做主键，往往不容易保证有序的插入，这样写数据成本相对较高。

2. 除了性能外，还需要考虑存储空间。

   > 我们应该使用身份证做主键，还是用自增字段做主键呢？
   >
   > 如果使用身份证做主键，每个二级索引的叶子结点占用20字节。如果使用整型或长整型(bigint)则需4或8字节。

3. **那些情况适合业务字段直接做主键？**

   > 1. 只有一个索引
   > 2. 该索引必须是唯一索引。KV场景
   >
   > 这时候应该将索引设为主键，避免搜索两棵树。